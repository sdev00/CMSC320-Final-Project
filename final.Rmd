---
title: "final"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(reticulate)
library(rgeolocate)
library(stringr)
library(dplyr)
```

## Introduction
The data consists of approximately 60,000 login attempts and 1500 attack sessions split among 3000 files.
Each most deeply nested folder represents a single instance of a single container. An instance folder will contain, among others, an attempts.txt file and a mitmlog_30*.txt file.
```{r ingestion}

# locate all of the relevant files
# attempts contains tidy login data: each line contains data about a unique login attempt
attempts <- list.files(pattern = "attempts", recursive = TRUE)
# mitmlogs contains the raw logs generated by the MITM
mitmlogs <- list.files(pattern = "mitmlog", recursive = TRUE)
files <- data.frame(Attempts=attempts, Logs=mitmlogs)

# the binary database used by ip2location
ip_database <- system.file("extdata","GeoLite2-Country.mmdb", package = "rgeolocate")

# have patience: this next step took about 88 seconds on my computer
# parses a single line in an attempts file
parseLine <- function(line) {
  # I'm lucky none of the attackers used a semicolon in their password guess; this could've been irritating
  segments <- strsplit(line, ";")
  location <- maxmind(segments[[1]][2], ip_database)
  return(data.frame(Time=segments[[1]][1],
                    Address=segments[[1]][2],
                    Method=segments[[1]][3],
                    Username=segments[[1]][4],
                    Password=segments[[1]][5],
                    CountryCode=location[3][1],
                    CountryName=location[2][1]))
}

# parses a single attempts/mitmlog pair
parseFile <- function(file) {
  lines <- readLines(con = file[1])
  log <- readLines(con = file[2])
  # the MITM appends a line containing "[LXC-Auth]" when an attacker enters the container; there will be one such line per file
  stime <- as.POSIXct(strsplit(
    Filter(
      function(x) {
        return (str_detect(x, "\\[LXC-Auth\\]"))
      },
      log)[1],
    " - ")[[1]][1])
  # once an attacker has entered the honeypot, an iptables rule is created to block any other connection attempts
  # when the attacker leaves the honeypot (or is forced out), the container is shut down, destroyed, and rebuilt from scratch
  # as such, the last line in the log entry for that instance of the container is the point at which the attacker was last active
  etime <- as.POSIXct(strsplit(
    tail(log, 1)[1],
    " - ")[[1]][1])
  # 
  elapsed <- as.double(difftime(etime, stime, units="secs"))
  file_df <- rbindlist(lapply(lines, parseLine))
  # the time in the 
  closest_time <- rbindlist(apply(file_df, 1, function(x) {
    return(data.frame(Time=x[1], Difference=abs(difftime(x[1], stime, units="secs"))))
    }))
  closest_time <- closest_time %>%
          slice(which.min(Difference))
  file_df <- as_tibble(file_df) %>%
    mutate(Authenticated=(Time==closest_time[1,1])) %>%
    mutate(Duration=ifelse(Authenticated==TRUE, elapsed, NA))
  return(file_df)
}

attempt_df <- rbindlist(apply(files, 1, parseFile))
attempt_df
```

```{python Sahil}
print(r.attempt_df['Time'][0])
```

